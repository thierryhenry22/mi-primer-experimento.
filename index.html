<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Rider - Aurora Extreme</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #ui { 
            position: absolute; top: 30px; width: 100%; text-align: center; 
            color: #00f2ff; font-size: 2.5rem; font-weight: bold;
            text-shadow: 0 0 20px #00f2ff; pointer-events: none; z-index: 100;
        }
    </style>
</head>
<body>

    <div id="ui">VELOCIDAD: <span id="speed">0</span> KM/H</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- MOTOR Y ESCENA ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- CIELO REALISTA (AURORA Y ESTRELLAS) ---
        const loader = new THREE.TextureLoader();
        // Usamos una imagen de 360 grados para el cielo
        const skyTexture = loader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/2294472375_b4a847347c_o.jpg');
        scene.background = skyTexture;

        // --- LUCES ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const spotLight = new THREE.SpotLight(0x00f2ff, 2);
        spotLight.position.set(0, 10, 10);
        scene.add(spotLight);

        // --- CARRETERA ---
        const roadTexture = loader.load('https://threejs.org/examples/textures/floors/FloorsCheckerboard_S_Diffuse.jpg'); // Provisional para ver movimiento
        const roadGeo = new THREE.PlaneGeometry(12, 2000);
        const roadMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.rotation.x = -Math.PI / 2;
        scene.add(road);

        const lineGeo = new THREE.PlaneGeometry(0.2, 2000);
        const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const line = new THREE.Mesh(lineGeo, lineMat);
        line.rotation.x = -Math.PI / 2;
        line.position.y = 0.05;
        scene.add(line);

        // --- NIEVE REALISTA ---
        const snowGeo = new THREE.PlaneGeometry(200, 2000, 10, 10);
        const snowMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
        const snow = new THREE.Mesh(snowGeo, snowMat);
        snow.rotation.x = -Math.PI / 2;
        snow.position.y = -0.1;
        scene.add(snow);

        // --- ÁRBOLES REALISTAS (PINOS) ---
        const trees = [];
        function createTree(z) {
            const group = new THREE.Group();
            
            // Tronco
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.3, 1.5),
                new THREE.MeshPhongMaterial({ color: 0x2e1b0d })
            );
            
            // Varias capas de hojas para realismo
            for(let i = 0; i < 3; i++) {
                const leaves = new THREE.Mesh(
                    new THREE.ConeGeometry(1.5 - (i*0.3), 2.5, 8),
                    new THREE.MeshPhongMaterial({ color: 0xffffff }) // Nieve sobre verde
                );
                leaves.position.y = 1.5 + (i * 1.2);
                group.add(leaves);
            }
            
            group.add(trunk);
            group.position.set(Math.random() > 0.5 ? 9 : -9, 0, z);
            scene.add(group);
            trees.push(group);
        }

        for(let i = 0; i > -500; i -= 25) createTree(i);

        // --- MOTO PRO ---
        const bike = new THREE.Group();
        const chassis = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.5, 2.2), new THREE.MeshPhongMaterial({color: 0x050505}));
        const neonStrip = new THREE.Mesh(new THREE.BoxGeometry(0.85, 0.1, 1.5), new THREE.MeshBasicMaterial({color: 0x8b5cf6}));
        neonStrip.position.y = 0.2;
        bike.add(chassis, neonStrip);
        scene.add(bike);
        bike.position.y = 0.6;

        camera.position.set(0, 4, 10);

        // --- CONTROLES Y MOVIMIENTO ---
        let keys = {};
        window.onkeydown = (e) => keys[e.key] = true;
        window.onkeyup = (e) => keys[e.key] = false;

        let velocity = 0;

        function animate() {
            requestAnimationFrame(animate);

            if(keys["ArrowUp"]) velocity += 0.008;
            else velocity *= 0.97;
            if(velocity > 1.2) velocity = 1.2;

            if(keys["ArrowLeft"] && bike.position.x > -5) {
                bike.position.x -= 0.15;
                bike.rotation.z = 0.2;
            } else if(keys["ArrowRight"] && bike.position.x < 5) {
                bike.position.x += 0.15;
                bike.rotation.z = -0.2;
            } else {
                bike.rotation.z *= 0.9;
            }

            // Movimiento infinito del mundo
            const speedFactor = velocity * 70;
            road.position.z += speedFactor;
            line.position.z += speedFactor;
            snow.position.z += speedFactor;

            if(road.position.z > 500) {
                road.position.z = 0;
                line.position.z = 0;
                snow.position.z = 0;
            }

            trees.forEach(t => {
                t.position.z += speedFactor;
                if(t.position.z > 20) t.position.z = -480;
            });

            // Cámara sigue a la moto
            camera.position.x += (bike.position.x - camera.position.x) * 0.1;
            camera.lookAt(bike.position.x, 1, -10);

            document.getElementById('speed').innerText = Math.floor(velocity * 320);
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
